#include "raylib.h"
#include "raymath.h"
#include "rlgl.h"
#define RAYGUI_IMPLEMENTATION
#include "raygui.h"
#define PHYSAC_IMPLEMENTATION
#include "physac.h"
char *structNames[] = {"Vector2","Vector3","Vector4","Matrix","Color","Rectangle","Image","Texture","RenderTexture","NPatchInfo","GlyphInfo","Font","Camera3D","Camera2D","Mesh","Shader","MaterialMap","Material","Transform","BoneInfo","Model","ModelAnimation","Ray","RayCollision","BoundingBox","Wave","AudioStream","Sound","Music","VrDeviceInfo","VrStereoConfig","FilePathList","AutomationEvent","AutomationEventList",};
int structSizes[] = {sizeof(Vector2),sizeof(Vector3),sizeof(Vector4),sizeof(Matrix),sizeof(Color),sizeof(Rectangle),sizeof(Image),sizeof(Texture),sizeof(RenderTexture),sizeof(NPatchInfo),sizeof(GlyphInfo),sizeof(Font),sizeof(Camera3D),sizeof(Camera2D),sizeof(Mesh),sizeof(Shader),sizeof(MaterialMap),sizeof(Material),sizeof(Transform),sizeof(BoneInfo),sizeof(Model),sizeof(ModelAnimation),sizeof(Ray),sizeof(RayCollision),sizeof(BoundingBox),sizeof(Wave),sizeof(AudioStream),sizeof(Sound),sizeof(Music),sizeof(VrDeviceInfo),sizeof(VrStereoConfig),sizeof(FilePathList),sizeof(AutomationEvent),sizeof(AutomationEventList),};
int StructCount() {return 34;}

int GetStructSize(int index) {return structSizes[index];}
void GetStructName(char *retName, int strlen, int index) {
  for (int i=0;i<strlen;i++) {
    retName[i] = structNames[index][i];
  }
}
void WindowShouldCloseRetPtr(bool *ret){*ret=WindowShouldClose();}                               // Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
void IsWindowReadyRetPtr(bool *ret){*ret=IsWindowReady();}                                   // Check if window has been initialized successfully
void IsWindowFullscreenRetPtr(bool *ret){*ret=IsWindowFullscreen();}                              // Check if window is currently fullscreen
void IsWindowHiddenRetPtr(bool *ret){*ret=IsWindowHidden();}                                  // Check if window is currently hidden (only PLATFORM_DESKTOP)
void IsWindowMinimizedRetPtr(bool *ret){*ret=IsWindowMinimized();}                               // Check if window is currently minimized (only PLATFORM_DESKTOP)
void IsWindowMaximizedRetPtr(bool *ret){*ret=IsWindowMaximized();}                               // Check if window is currently maximized (only PLATFORM_DESKTOP)
void IsWindowFocusedRetPtr(bool *ret){*ret=IsWindowFocused();}                                 // Check if window is currently focused (only PLATFORM_DESKTOP)
void IsWindowResizedRetPtr(bool *ret){*ret=IsWindowResized();}                                 // Check if window has been resized last frame
void IsWindowStateRetPtr(bool *ret, unsigned int flag){*ret=IsWindowState(flag);}                      // Check if one specific window flag is enabled
void GetWindowHandleRetPtr(void **ret){*ret=GetWindowHandle();}                                // Get native window handle
void GetScreenWidthRetPtr(int *ret){*ret=GetScreenWidth();}                                   // Get current screen width
void GetScreenHeightRetPtr(int *ret){*ret=GetScreenHeight();}                                  // Get current screen height
void GetRenderWidthRetPtr(int *ret){*ret=GetRenderWidth();}                                   // Get current render width (it considers HiDPI)
void GetRenderHeightRetPtr(int *ret){*ret=GetRenderHeight();}                                  // Get current render height (it considers HiDPI)
void GetMonitorCountRetPtr(int *ret){*ret=GetMonitorCount();}                                  // Get number of connected monitors
void GetCurrentMonitorRetPtr(int *ret){*ret=GetCurrentMonitor();}                                // Get current connected monitor
void GetMonitorPositionRetPtr(Vector2 *ret, int monitor){*ret=GetMonitorPosition(monitor);}                    // Get specified monitor position
void GetMonitorWidthRetPtr(int *ret, int monitor){*ret=GetMonitorWidth(monitor);}                           // Get specified monitor width (current video mode used by monitor)
void GetMonitorHeightRetPtr(int *ret, int monitor){*ret=GetMonitorHeight(monitor);}                          // Get specified monitor height (current video mode used by monitor)
void GetMonitorPhysicalWidthRetPtr(int *ret, int monitor){*ret=GetMonitorPhysicalWidth(monitor);}                   // Get specified monitor physical width in millimetres
void GetMonitorPhysicalHeightRetPtr(int *ret, int monitor){*ret=GetMonitorPhysicalHeight(monitor);}                  // Get specified monitor physical height in millimetres
void GetMonitorRefreshRateRetPtr(int *ret, int monitor){*ret=GetMonitorRefreshRate(monitor);}                     // Get specified monitor refresh rate
void GetWindowPositionRetPtr(Vector2 *ret){*ret=GetWindowPosition();}                            // Get window position XY on monitor
void GetWindowScaleDPIRetPtr(Vector2 *ret){*ret=GetWindowScaleDPI();}                            // Get window scale DPI factor
void GetMonitorNameRetPtr(const char **ret, int monitor){*ret=GetMonitorName(monitor);}                    // Get the human-readable, UTF-8 encoded name of the specified monitor
void GetClipboardTextRetPtr(const char **ret){*ret=GetClipboardText();}                         // Get clipboard text content
void IsCursorHiddenRetPtr(bool *ret){*ret=IsCursorHidden();}                                  // Check if cursor is not visible
void IsCursorOnScreenRetPtr(bool *ret){*ret=IsCursorOnScreen();}                                // Check if cursor is on the screen
void LoadVrStereoConfigRetPtr(VrStereoConfig *ret, VrDeviceInfo device){*ret=LoadVrStereoConfig(device);}     // Load VR stereo config for VR simulator device parameters
void LoadShaderRetPtr(Shader *ret, const char *vsFileName, const char *fsFileName){*ret=LoadShader(vsFileName, fsFileName);}   // Load shader from files and bind default locations
void LoadShaderFromMemoryRetPtr(Shader *ret, const char *vsCode, const char *fsCode){*ret=LoadShaderFromMemory(vsCode, fsCode);} // Load shader from code strings and bind default locations
void IsShaderReadyRetPtr(bool *ret, Shader shader){*ret=IsShaderReady(shader);}                                   // Check if a shader is ready
void GetShaderLocationRetPtr(int *ret, Shader shader, const char *uniformName){*ret=GetShaderLocation(shader, uniformName);}       // Get shader uniform location
void GetShaderLocationAttribRetPtr(int *ret, Shader shader, const char *attribName){*ret=GetShaderLocationAttrib(shader, attribName);}  // Get shader attribute location
void GetMouseRayRetPtr(Ray *ret, Vector2 mousePosition, Camera camera){*ret=GetMouseRay(mousePosition, camera);}      // Get a ray trace from mouse position
void GetCameraMatrixRetPtr(Matrix *ret, Camera camera){*ret=GetCameraMatrix(camera);}                      // Get camera transform matrix (view matrix)
void GetCameraMatrix2DRetPtr(Matrix *ret, Camera2D camera){*ret=GetCameraMatrix2D(camera);}                  // Get camera 2d transform matrix
void GetWorldToScreenRetPtr(Vector2 *ret, Vector3 position, Camera camera){*ret=GetWorldToScreen(position, camera);}  // Get the screen space position for a 3d world space position
void GetScreenToWorld2DRetPtr(Vector2 *ret, Vector2 position, Camera2D camera){*ret=GetScreenToWorld2D(position, camera);} // Get the world space position for a 2d camera screen space position
void GetWorldToScreenExRetPtr(Vector2 *ret, Vector3 position, Camera camera, int width, int height){*ret=GetWorldToScreenEx(position, camera, width, height);} // Get size position for a 3d world space position
void GetWorldToScreen2DRetPtr(Vector2 *ret, Vector2 position, Camera2D camera){*ret=GetWorldToScreen2D(position, camera);} // Get the screen space position for a 2d camera world space position
void GetFrameTimeRetPtr(float *ret){*ret=GetFrameTime();}                                   // Get time in seconds for last frame drawn (delta time)
void GetTimeRetPtr(double *ret){*ret=GetTime();}                                       // Get elapsed time in seconds since InitWindow()
void GetFPSRetPtr(int *ret){*ret=GetFPS();}                                           // Get current FPS
void GetRandomValueRetPtr(int *ret, int min, int max){*ret=GetRandomValue(min, max);}                       // Get a random value between min and max (both included)
void LoadRandomSequenceRetPtr(int **ret, unsigned int count, int min, int max){*ret=LoadRandomSequence(count, min, max);} // Load random values sequence, no values repeated
void MemAllocRetPtr(void **ret, unsigned int size){*ret=MemAlloc(size);}                          // Internal memory allocator
void MemReallocRetPtr(void **ret, void *ptr, unsigned int size){*ret=MemRealloc(ptr, size);}             // Internal memory reallocator
void LoadFileDataRetPtr(unsigned char **ret, const char *fileName, int *dataSize){*ret=LoadFileData(fileName, dataSize);} // Load file data as byte array (read)
void SaveFileDataRetPtr(bool *ret, const char *fileName, void *data, int dataSize){*ret=SaveFileData(fileName, data, dataSize);} // Save data to file from byte array (write), returns true on success
void ExportDataAsCodeRetPtr(bool *ret, const unsigned char *data, int dataSize, const char *fileName){*ret=ExportDataAsCode(data, dataSize, fileName);} // Export data to code (.h), returns true on success
void LoadFileTextRetPtr(char **ret, const char *fileName){*ret=LoadFileText(fileName);}                   // Load text data from file (read), returns a '\0' terminated string
void SaveFileTextRetPtr(bool *ret, const char *fileName, char *text){*ret=SaveFileText(fileName, text);}        // Save text data to file (write), string must be '\0' terminated, returns true on success
void FileExistsRetPtr(bool *ret, const char *fileName){*ret=FileExists(fileName);}                      // Check if file exists
void DirectoryExistsRetPtr(bool *ret, const char *dirPath){*ret=DirectoryExists(dirPath);}                  // Check if a directory path exists
void IsFileExtensionRetPtr(bool *ret, const char *fileName, const char *ext){*ret=IsFileExtension(fileName, ext);} // Check file extension (including point: .png, .wav)
void GetFileLengthRetPtr(int *ret, const char *fileName){*ret=GetFileLength(fileName);}                    // Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
void GetFileExtensionRetPtr(const char **ret, const char *fileName){*ret=GetFileExtension(fileName);}         // Get pointer to extension for a filename string (includes dot: '.png')
void GetFileNameRetPtr(const char **ret, const char *filePath){*ret=GetFileName(filePath);}              // Get pointer to filename for a path string
void GetFileNameWithoutExtRetPtr(const char **ret, const char *filePath){*ret=GetFileNameWithoutExt(filePath);}    // Get filename string without extension (uses static string)
void GetDirectoryPathRetPtr(const char **ret, const char *filePath){*ret=GetDirectoryPath(filePath);}         // Get full path for a given fileName with path (uses static string)
void GetPrevDirectoryPathRetPtr(const char **ret, const char *dirPath){*ret=GetPrevDirectoryPath(dirPath);}      // Get previous directory path for a given path (uses static string)
void GetWorkingDirectoryRetPtr(const char **ret){*ret=GetWorkingDirectory();}                      // Get current working directory (uses static string)
void GetApplicationDirectoryRetPtr(const char **ret){*ret=GetApplicationDirectory();}                  // Get the directory of the running application (uses static string)
void ChangeDirectoryRetPtr(bool *ret, const char *dir){*ret=ChangeDirectory(dir);}                      // Change working directory, return true on success
void IsPathFileRetPtr(bool *ret, const char *path){*ret=IsPathFile(path);}                          // Check if a given path is a file or a directory
void LoadDirectoryFilesRetPtr(FilePathList *ret, const char *dirPath){*ret=LoadDirectoryFiles(dirPath);}       // Load directory filepaths
void LoadDirectoryFilesExRetPtr(FilePathList *ret, const char *basePath, const char *filter, bool scanSubdirs){*ret=LoadDirectoryFilesEx(basePath, filter, scanSubdirs);} // Load directory filepaths with extension filtering and recursive directory scan
void IsFileDroppedRetPtr(bool *ret){*ret=IsFileDropped();}                                   // Check if a file has been dropped into window
void LoadDroppedFilesRetPtr(FilePathList *ret){*ret=LoadDroppedFiles();}                        // Load dropped filepaths
void GetFileModTimeRetPtr(long *ret, const char *fileName){*ret=GetFileModTime(fileName);}                  // Get file modification time (last write time)
void CompressDataRetPtr(unsigned char **ret, const unsigned char *data, int dataSize, int *compDataSize){*ret=CompressData(data, dataSize, compDataSize);}        // Compress data (DEFLATE algorithm), memory must be MemFree()
void DecompressDataRetPtr(unsigned char **ret, const unsigned char *compData, int compDataSize, int *dataSize){*ret=DecompressData(compData, compDataSize, dataSize);}  // Decompress data (DEFLATE algorithm), memory must be MemFree()
void EncodeDataBase64RetPtr(char **ret, const unsigned char *data, int dataSize, int *outputSize){*ret=EncodeDataBase64(data, dataSize, outputSize);}               // Encode data to Base64 string, memory must be MemFree()
void DecodeDataBase64RetPtr(unsigned char **ret, const unsigned char *data, int *outputSize){*ret=DecodeDataBase64(data, outputSize);}                    // Decode Base64 string data, memory must be MemFree()
void LoadAutomationEventListRetPtr(AutomationEventList *ret, const char *fileName){*ret=LoadAutomationEventList(fileName);}                // Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
void ExportAutomationEventListRetPtr(bool *ret, AutomationEventList list, const char *fileName){*ret=ExportAutomationEventList(list, fileName);}   // Export automation events list as text file
void IsKeyPressedRetPtr(bool *ret, int key){*ret=IsKeyPressed(key);}                             // Check if a key has been pressed once
void IsKeyPressedRepeatRetPtr(bool *ret, int key){*ret=IsKeyPressedRepeat(key);}                       // Check if a key has been pressed again (Only PLATFORM_DESKTOP)
void IsKeyDownRetPtr(bool *ret, int key){*ret=IsKeyDown(key);}                                // Check if a key is being pressed
void IsKeyReleasedRetPtr(bool *ret, int key){*ret=IsKeyReleased(key);}                            // Check if a key has been released once
void IsKeyUpRetPtr(bool *ret, int key){*ret=IsKeyUp(key);}                                  // Check if a key is NOT being pressed
void GetKeyPressedRetPtr(int *ret){*ret=GetKeyPressed();}                                // Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
void GetCharPressedRetPtr(int *ret){*ret=GetCharPressed();}                               // Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
void IsGamepadAvailableRetPtr(bool *ret, int gamepad){*ret=IsGamepadAvailable(gamepad);}                   // Check if a gamepad is available
void GetGamepadNameRetPtr(const char **ret, int gamepad){*ret=GetGamepadName(gamepad);}                // Get gamepad internal name id
void IsGamepadButtonPressedRetPtr(bool *ret, int gamepad, int button){*ret=IsGamepadButtonPressed(gamepad, button);}   // Check if a gamepad button has been pressed once
void IsGamepadButtonDownRetPtr(bool *ret, int gamepad, int button){*ret=IsGamepadButtonDown(gamepad, button);}      // Check if a gamepad button is being pressed
void IsGamepadButtonReleasedRetPtr(bool *ret, int gamepad, int button){*ret=IsGamepadButtonReleased(gamepad, button);}  // Check if a gamepad button has been released once
void IsGamepadButtonUpRetPtr(bool *ret, int gamepad, int button){*ret=IsGamepadButtonUp(gamepad, button);}        // Check if a gamepad button is NOT being pressed
void GetGamepadButtonPressedRetPtr(int *ret){*ret=GetGamepadButtonPressed();}                      // Get the last gamepad button pressed
void GetGamepadAxisCountRetPtr(int *ret, int gamepad){*ret=GetGamepadAxisCount(gamepad);}                   // Get gamepad axis count for a gamepad
void GetGamepadAxisMovementRetPtr(float *ret, int gamepad, int axis){*ret=GetGamepadAxisMovement(gamepad, axis);}    // Get axis movement value for a gamepad axis
void SetGamepadMappingsRetPtr(int *ret, const char *mappings){*ret=SetGamepadMappings(mappings);}           // Set internal gamepad mappings (SDL_GameControllerDB)
void IsMouseButtonPressedRetPtr(bool *ret, int button){*ret=IsMouseButtonPressed(button);}                  // Check if a mouse button has been pressed once
void IsMouseButtonDownRetPtr(bool *ret, int button){*ret=IsMouseButtonDown(button);}                     // Check if a mouse button is being pressed
void IsMouseButtonReleasedRetPtr(bool *ret, int button){*ret=IsMouseButtonReleased(button);}                 // Check if a mouse button has been released once
void IsMouseButtonUpRetPtr(bool *ret, int button){*ret=IsMouseButtonUp(button);}                       // Check if a mouse button is NOT being pressed
void GetMouseXRetPtr(int *ret){*ret=GetMouseX();}                                    // Get mouse position X
void GetMouseYRetPtr(int *ret){*ret=GetMouseY();}                                    // Get mouse position Y
void GetMousePositionRetPtr(Vector2 *ret){*ret=GetMousePosition();}                         // Get mouse position XY
void GetMouseDeltaRetPtr(Vector2 *ret){*ret=GetMouseDelta();}                            // Get mouse delta between frames
void GetMouseWheelMoveRetPtr(float *ret){*ret=GetMouseWheelMove();}                          // Get mouse wheel movement for X or Y, whichever is larger
void GetMouseWheelMoveVRetPtr(Vector2 *ret){*ret=GetMouseWheelMoveV();}                       // Get mouse wheel movement for both X and Y
void GetTouchXRetPtr(int *ret){*ret=GetTouchX();}                                    // Get touch position X for touch point 0 (relative to screen size)
void GetTouchYRetPtr(int *ret){*ret=GetTouchY();}                                    // Get touch position Y for touch point 0 (relative to screen size)
void GetTouchPositionRetPtr(Vector2 *ret, int index){*ret=GetTouchPosition(index);}                    // Get touch position XY for a touch point index (relative to screen size)
void GetTouchPointIdRetPtr(int *ret, int index){*ret=GetTouchPointId(index);}                         // Get touch point identifier for given index
void GetTouchPointCountRetPtr(int *ret){*ret=GetTouchPointCount();}                           // Get number of touch points
void IsGestureDetectedRetPtr(bool *ret, unsigned int gesture){*ret=IsGestureDetected(gesture);}     // Check if a gesture have been detected
void GetGestureDetectedRetPtr(int *ret){*ret=GetGestureDetected();}                     // Get latest detected gesture
void GetGestureHoldDurationRetPtr(float *ret){*ret=GetGestureHoldDuration();}               // Get gesture hold time in milliseconds
void GetGestureDragVectorRetPtr(Vector2 *ret){*ret=GetGestureDragVector();}               // Get gesture drag vector
void GetGestureDragAngleRetPtr(float *ret){*ret=GetGestureDragAngle();}                  // Get gesture drag angle
void GetGesturePinchVectorRetPtr(Vector2 *ret){*ret=GetGesturePinchVector();}              // Get gesture pinch delta
void GetGesturePinchAngleRetPtr(float *ret){*ret=GetGesturePinchAngle();}                 // Get gesture pinch angle
void GetSplinePointLinearRetPtr(Vector2 *ret, Vector2 startPos, Vector2 endPos, float t){*ret=GetSplinePointLinear(startPos, endPos, t);}                           // Get (evaluate) spline point: Linear
void GetSplinePointBasisRetPtr(Vector2 *ret, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t){*ret=GetSplinePointBasis(p1, p2, p3, p4, t);}              // Get (evaluate) spline point: B-Spline
void GetSplinePointCatmullRomRetPtr(Vector2 *ret, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t){*ret=GetSplinePointCatmullRom(p1, p2, p3, p4, t);}         // Get (evaluate) spline point: Catmull-Rom
void GetSplinePointBezierQuadRetPtr(Vector2 *ret, Vector2 p1, Vector2 c2, Vector2 p3, float t){*ret=GetSplinePointBezierQuad(p1, c2, p3, t);}                     // Get (evaluate) spline point: Quadratic Bezier
void GetSplinePointBezierCubicRetPtr(Vector2 *ret, Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t){*ret=GetSplinePointBezierCubic(p1, c2, c3, p4, t);}        // Get (evaluate) spline point: Cubic Bezier
void CheckCollisionRecsRetPtr(bool *ret, Rectangle rec1, Rectangle rec2){*ret=CheckCollisionRecs(rec1, rec2);}                                           // Check collision between two rectangles
void CheckCollisionCirclesRetPtr(bool *ret, Vector2 center1, float radius1, Vector2 center2, float radius2){*ret=CheckCollisionCircles(center1, radius1, center2, radius2);}        // Check collision between two circles
void CheckCollisionCircleRecRetPtr(bool *ret, Vector2 center, float radius, Rectangle rec){*ret=CheckCollisionCircleRec(center, radius, rec);}                         // Check collision between circle and rectangle
void CheckCollisionPointRecRetPtr(bool *ret, Vector2 point, Rectangle rec){*ret=CheckCollisionPointRec(point, rec);}                                         // Check if point is inside rectangle
void CheckCollisionPointCircleRetPtr(bool *ret, Vector2 point, Vector2 center, float radius){*ret=CheckCollisionPointCircle(point, center, radius);}                       // Check if point is inside circle
void CheckCollisionPointTriangleRetPtr(bool *ret, Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3){*ret=CheckCollisionPointTriangle(point, p1, p2, p3);}               // Check if point is inside a triangle
void CheckCollisionPointPolyRetPtr(bool *ret, Vector2 point, Vector2 *points, int pointCount){*ret=CheckCollisionPointPoly(point, points, pointCount);}                      // Check if point is within a polygon described by array of vertices
void CheckCollisionLinesRetPtr(bool *ret, Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint){*ret=CheckCollisionLines(startPos1, endPos1, startPos2, endPos2, collisionPoint);} // Check the collision between two lines defined by two points each, returns collision point by reference
void CheckCollisionPointLineRetPtr(bool *ret, Vector2 point, Vector2 p1, Vector2 p2, int threshold){*ret=CheckCollisionPointLine(point, p1, p2, threshold);}                // Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
void GetCollisionRecRetPtr(Rectangle *ret, Rectangle rec1, Rectangle rec2){*ret=GetCollisionRec(rec1, rec2);}                                         // Get collision rectangle for two rectangles collision
void LoadImageRetPtr(Image *ret, const char *fileName){*ret=LoadImage(fileName);}                                                             // Load image from file into CPU memory (RAM)
void LoadImageRawRetPtr(Image *ret, const char *fileName, int width, int height, int format, int headerSize){*ret=LoadImageRaw(fileName, width, height, format, headerSize);}       // Load image from RAW file data
void LoadImageSvgRetPtr(Image *ret, const char *fileNameOrString, int width, int height){*ret=LoadImageSvg(fileNameOrString, width, height);}                           // Load image from SVG file data or string with specified size
void LoadImageAnimRetPtr(Image *ret, const char *fileName, int *frames){*ret=LoadImageAnim(fileName, frames);}                                            // Load image sequence from file (frames appended to image.data)
void LoadImageFromMemoryRetPtr(Image *ret, const char *fileType, const unsigned char *fileData, int dataSize){*ret=LoadImageFromMemory(fileType, fileData, dataSize);}      // Load image from memory buffer, fileType refers to extension: i.e. '.png'
void LoadImageFromTextureRetPtr(Image *ret, Texture2D texture){*ret=LoadImageFromTexture(texture);}                                                     // Load image from GPU texture data
void LoadImageFromScreenRetPtr(Image *ret){*ret=LoadImageFromScreen();}                                                                   // Load image from screen buffer and (screenshot)
void IsImageReadyRetPtr(bool *ret, Image image){*ret=IsImageReady(image);}                                                                    // Check if an image is ready
void ExportImageRetPtr(bool *ret, Image image, const char *fileName){*ret=ExportImage(image, fileName);}                                               // Export image data to file, returns true on success
void ExportImageToMemoryRetPtr(unsigned char **ret, Image image, const char *fileType, int *fileSize){*ret=ExportImageToMemory(image, fileType, fileSize);}              // Export image to memory buffer
void ExportImageAsCodeRetPtr(bool *ret, Image image, const char *fileName){*ret=ExportImageAsCode(image, fileName);}                                         // Export image as code file defining an array of bytes, returns true on success
void GenImageColorRetPtr(Image *ret, int width, int height, Color color){*ret=GenImageColor(width, height, color);}                                           // Generate image: plain color
void GenImageGradientLinearRetPtr(Image *ret, int width, int height, int direction, Color start, Color end){*ret=GenImageGradientLinear(width, height, direction, start, end);}        // Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
void GenImageGradientRadialRetPtr(Image *ret, int width, int height, float density, Color inner, Color outer){*ret=GenImageGradientRadial(width, height, density, inner, outer);}      // Generate image: radial gradient
void GenImageGradientSquareRetPtr(Image *ret, int width, int height, float density, Color inner, Color outer){*ret=GenImageGradientSquare(width, height, density, inner, outer);}      // Generate image: square gradient
void GenImageCheckedRetPtr(Image *ret, int width, int height, int checksX, int checksY, Color col1, Color col2){*ret=GenImageChecked(width, height, checksX, checksY, col1, col2);}    // Generate image: checked
void GenImageWhiteNoiseRetPtr(Image *ret, int width, int height, float factor){*ret=GenImageWhiteNoise(width, height, factor);}                                     // Generate image: white noise
void GenImagePerlinNoiseRetPtr(Image *ret, int width, int height, int offsetX, int offsetY, float scale){*ret=GenImagePerlinNoise(width, height, offsetX, offsetY, scale);}           // Generate image: perlin noise
void GenImageCellularRetPtr(Image *ret, int width, int height, int tileSize){*ret=GenImageCellular(width, height, tileSize);}                                       // Generate image: cellular algorithm, bigger tileSize means bigger cells
void GenImageTextRetPtr(Image *ret, int width, int height, const char *text){*ret=GenImageText(width, height, text);}                                       // Generate image: grayscale image from text data
void ImageCopyRetPtr(Image *ret, Image image){*ret=ImageCopy(image);}                                                                      // Create an image duplicate (useful for transformations)
void ImageFromImageRetPtr(Image *ret, Image image, Rectangle rec){*ret=ImageFromImage(image, rec);}                                                  // Create an image from another image piece
void ImageTextRetPtr(Image *ret, const char *text, int fontSize, Color color){*ret=ImageText(text, fontSize, color);}                                      // Create an image from text (default font)
void ImageTextExRetPtr(Image *ret, Font font, const char *text, float fontSize, float spacing, Color tint){*ret=ImageTextEx(font, text, fontSize, spacing, tint);}         // Create an image from text (custom sprite font)
void LoadImageColorsRetPtr(Color **ret, Image image){*ret=LoadImageColors(image);}                                                               // Load color data from image as a Color array (RGBA - 32bit)
void LoadImagePaletteRetPtr(Color **ret, Image image, int maxPaletteSize, int *colorCount){*ret=LoadImagePalette(image, maxPaletteSize, colorCount);}                         // Load colors palette from image as a Color array (RGBA - 32bit)
void GetImageAlphaBorderRetPtr(Rectangle *ret, Image image, float threshold){*ret=GetImageAlphaBorder(image, threshold);}                                       // Get image alpha border rectangle
void GetImageColorRetPtr(Color *ret, Image image, int x, int y){*ret=GetImageColor(image, x, y);}                                                    // Get image pixel color at (x, y) position
void LoadTextureRetPtr(Texture2D *ret, const char *fileName){*ret=LoadTexture(fileName);}                                                       // Load texture from file into GPU memory (VRAM)
void LoadTextureFromImageRetPtr(Texture2D *ret, Image image){*ret=LoadTextureFromImage(image);}                                                       // Load texture from image data
void LoadTextureCubemapRetPtr(TextureCubemap *ret, Image image, int layout){*ret=LoadTextureCubemap(image, layout);}                                        // Load cubemap from image, multiple image cubemap layouts supported
void LoadRenderTextureRetPtr(RenderTexture2D *ret, int width, int height){*ret=LoadRenderTexture(width, height);}                                          // Load texture for rendering (framebuffer)
void IsTextureReadyRetPtr(bool *ret, Texture2D texture){*ret=IsTextureReady(texture);}                                                            // Check if a texture is ready
void IsRenderTextureReadyRetPtr(bool *ret, RenderTexture2D target){*ret=IsRenderTextureReady(target);}                                                 // Check if a render texture is ready
void FadeRetPtr(Color *ret, Color color, float alpha){*ret=Fade(color, alpha);}                                 // Get color with alpha applied, alpha goes from 0.0f to 1.0f
void ColorToIntRetPtr(int *ret, Color color){*ret=ColorToInt(color);}                                          // Get hexadecimal value for a Color
void ColorNormalizeRetPtr(Vector4 *ret, Color color){*ret=ColorNormalize(color);}                                  // Get Color normalized as float [0..1]
void ColorFromNormalizedRetPtr(Color *ret, Vector4 normalized){*ret=ColorFromNormalized(normalized);}                        // Get Color from normalized values [0..1]
void ColorToHSVRetPtr(Vector3 *ret, Color color){*ret=ColorToHSV(color);}                                      // Get HSV values for a Color, hue [0..360], saturation/value [0..1]
void ColorFromHSVRetPtr(Color *ret, float hue, float saturation, float value){*ret=ColorFromHSV(hue, saturation, value);}         // Get a Color from HSV values, hue [0..360], saturation/value [0..1]
void ColorTintRetPtr(Color *ret, Color color, Color tint){*ret=ColorTint(color, tint);}                             // Get color multiplied with another color
void ColorBrightnessRetPtr(Color *ret, Color color, float factor){*ret=ColorBrightness(color, factor);}                     // Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
void ColorContrastRetPtr(Color *ret, Color color, float contrast){*ret=ColorContrast(color, contrast);}                     // Get color with contrast correction, contrast values between -1.0f and 1.0f
void ColorAlphaRetPtr(Color *ret, Color color, float alpha){*ret=ColorAlpha(color, alpha);}                           // Get color with alpha applied, alpha goes from 0.0f to 1.0f
void ColorAlphaBlendRetPtr(Color *ret, Color dst, Color src, Color tint){*ret=ColorAlphaBlend(dst, src, tint);}              // Get src alpha-blended into dst color with tint
void GetColorRetPtr(Color *ret, unsigned int hexValue){*ret=GetColor(hexValue);}                                // Get Color structure from hexadecimal value
void GetPixelColorRetPtr(Color *ret, void *srcPtr, int format){*ret=GetPixelColor(srcPtr, format);}                        // Get Color from a source pixel pointer of certain format
void GetPixelDataSizeRetPtr(int *ret, int width, int height, int format){*ret=GetPixelDataSize(width, height, format);}              // Get pixel data size in bytes for certain format
void GetFontDefaultRetPtr(Font *ret){*ret=GetFontDefault();}                                                            // Get the default Font
void LoadFontRetPtr(Font *ret, const char *fileName){*ret=LoadFont(fileName);}                                                  // Load font from file into GPU memory (VRAM)
void LoadFontExRetPtr(Font *ret, const char *fileName, int fontSize, int *codepoints, int codepointCount){*ret=LoadFontEx(fileName, fontSize, codepoints, codepointCount);}  // Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set
void LoadFontFromImageRetPtr(Font *ret, Image image, Color key, int firstChar){*ret=LoadFontFromImage(image, key, firstChar);}                        // Load font from Image (XNA style)
void LoadFontFromMemoryRetPtr(Font *ret, const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount){*ret=LoadFontFromMemory(fileType, fileData, dataSize, fontSize, codepoints, codepointCount);} // Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
void IsFontReadyRetPtr(bool *ret, Font font){*ret=IsFontReady(font);}                                                          // Check if a font is ready
void LoadFontDataRetPtr(GlyphInfo **ret, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type){*ret=LoadFontData(fileData, dataSize, fontSize, codepoints, codepointCount, type);} // Load font data for further use
void GenImageFontAtlasRetPtr(Image *ret, const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod){*ret=GenImageFontAtlas(glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod);} // Generate image font atlas using chars info
void ExportFontAsCodeRetPtr(bool *ret, Font font, const char *fileName){*ret=ExportFontAsCode(font, fileName);}                               // Export font as code file, returns true on success
void MeasureTextRetPtr(int *ret, const char *text, int fontSize){*ret=MeasureText(text, fontSize);}                                      // Measure string width for default font
void MeasureTextExRetPtr(Vector2 *ret, Font font, const char *text, float fontSize, float spacing){*ret=MeasureTextEx(font, text, fontSize, spacing);}    // Measure string size for Font
void GetGlyphIndexRetPtr(int *ret, Font font, int codepoint){*ret=GetGlyphIndex(font, codepoint);}                                          // Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
void GetGlyphInfoRetPtr(GlyphInfo *ret, Font font, int codepoint){*ret=GetGlyphInfo(font, codepoint);}                                     // Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
void GetGlyphAtlasRecRetPtr(Rectangle *ret, Font font, int codepoint){*ret=GetGlyphAtlasRec(font, codepoint);}                                 // Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
void LoadUTF8RetPtr(char **ret, const int *codepoints, int length){*ret=LoadUTF8(codepoints, length);}                // Load UTF-8 text encoded from codepoints array
void LoadCodepointsRetPtr(int **ret, const char *text, int *count){*ret=LoadCodepoints(text, count);}                // Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
void GetCodepointCountRetPtr(int *ret, const char *text){*ret=GetCodepointCount(text);}                          // Get total number of codepoints in a UTF-8 encoded string
void GetCodepointRetPtr(int *ret, const char *text, int *codepointSize){*ret=GetCodepoint(text, codepointSize);}           // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
void GetCodepointNextRetPtr(int *ret, const char *text, int *codepointSize){*ret=GetCodepointNext(text, codepointSize);}       // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
void GetCodepointPreviousRetPtr(int *ret, const char *text, int *codepointSize){*ret=GetCodepointPrevious(text, codepointSize);}   // Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
void CodepointToUTF8RetPtr(const char **ret, int codepoint, int *utf8Size){*ret=CodepointToUTF8(codepoint, utf8Size);}        // Encode one codepoint into UTF-8 byte array (array length returned as parameter)
void TextCopyRetPtr(int *ret, char *dst, const char *src){*ret=TextCopy(dst, src);}                                             // Copy one string to another, returns bytes copied
void TextIsEqualRetPtr(bool *ret, const char *text1, const char *text2){*ret=TextIsEqual(text1, text2);}                               // Check if two text string are equal
void TextLengthRetPtr(unsigned int *ret, const char *text){*ret=TextLength(text);}                                            // Get text length, checks for '\0' ending
void TextSubtextRetPtr(const char **ret, const char *text, int position, int length){*ret=TextSubtext(text, position, length);}                  // Get a piece of a text string
void TextReplaceRetPtr(char **ret, char *text, const char *replace, const char *by){*ret=TextReplace(text, replace, by);}                   // Replace text string (WARNING: memory must be freed!)
void TextInsertRetPtr(char **ret, const char *text, const char *insert, int position){*ret=TextInsert(text, insert, position);}                 // Insert text in a position (WARNING: memory must be freed!)
void TextJoinRetPtr(const char **ret, const char **textList, int count, const char *delimiter){*ret=TextJoin(textList, count, delimiter);}        // Join text strings with delimiter
void TextSplitRetPtr(const char ***ret, const char *text, char delimiter, int *count){*ret=TextSplit(text, delimiter, count);}                 // Split text into multiple strings
void TextFindIndexRetPtr(int *ret, const char *text, const char *find){*ret=TextFindIndex(text, find);}                                // Find first text occurrence within a string
void TextToUpperRetPtr(const char **ret, const char *text){*ret=TextToUpper(text);}                      // Get upper case version of provided string
void TextToLowerRetPtr(const char **ret, const char *text){*ret=TextToLower(text);}                      // Get lower case version of provided string
void TextToPascalRetPtr(const char **ret, const char *text){*ret=TextToPascal(text);}                     // Get Pascal case notation version of provided string
void TextToIntegerRetPtr(int *ret, const char *text){*ret=TextToInteger(text);}                            // Get integer value from text (negative values not supported)
void LoadModelRetPtr(Model *ret, const char *fileName){*ret=LoadModel(fileName);}                                                // Load model from files (meshes and materials)
void LoadModelFromMeshRetPtr(Model *ret, Mesh mesh){*ret=LoadModelFromMesh(mesh);}                                                   // Load model from generated mesh (default material)
void IsModelReadyRetPtr(bool *ret, Model model){*ret=IsModelReady(model);}                                                       // Check if a model is ready
void GetModelBoundingBoxRetPtr(BoundingBox *ret, Model model){*ret=GetModelBoundingBox(model);}                                         // Compute model bounding box limits (considers all meshes)
void ExportMeshRetPtr(bool *ret, Mesh mesh, const char *fileName){*ret=ExportMesh(mesh, fileName);}                                     // Export mesh data to file, returns true on success
void GetMeshBoundingBoxRetPtr(BoundingBox *ret, Mesh mesh){*ret=GetMeshBoundingBox(mesh);}                                            // Compute mesh bounding box limits
void GenMeshPolyRetPtr(Mesh *ret, int sides, float radius){*ret=GenMeshPoly(sides, radius);}                                            // Generate polygonal mesh
void GenMeshPlaneRetPtr(Mesh *ret, float width, float length, int resX, int resZ){*ret=GenMeshPlane(width, length, resX, resZ);}                     // Generate plane mesh (with subdivisions)
void GenMeshCubeRetPtr(Mesh *ret, float width, float height, float length){*ret=GenMeshCube(width, height, length);}                            // Generate cuboid mesh
void GenMeshSphereRetPtr(Mesh *ret, float radius, int rings, int slices){*ret=GenMeshSphere(radius, rings, slices);}                              // Generate sphere mesh (standard sphere)
void GenMeshHemiSphereRetPtr(Mesh *ret, float radius, int rings, int slices){*ret=GenMeshHemiSphere(radius, rings, slices);}                          // Generate half-sphere mesh (no bottom cap)
void GenMeshCylinderRetPtr(Mesh *ret, float radius, float height, int slices){*ret=GenMeshCylinder(radius, height, slices);}                         // Generate cylinder mesh
void GenMeshConeRetPtr(Mesh *ret, float radius, float height, int slices){*ret=GenMeshCone(radius, height, slices);}                             // Generate cone/pyramid mesh
void GenMeshTorusRetPtr(Mesh *ret, float radius, float size, int radSeg, int sides){*ret=GenMeshTorus(radius, size, radSeg, sides);}                   // Generate torus mesh
void GenMeshKnotRetPtr(Mesh *ret, float radius, float size, int radSeg, int sides){*ret=GenMeshKnot(radius, size, radSeg, sides);}                    // Generate trefoil knot mesh
void GenMeshHeightmapRetPtr(Mesh *ret, Image heightmap, Vector3 size){*ret=GenMeshHeightmap(heightmap, size);}                                 // Generate heightmap mesh from image data
void GenMeshCubicmapRetPtr(Mesh *ret, Image cubicmap, Vector3 cubeSize){*ret=GenMeshCubicmap(cubicmap, cubeSize);}                               // Generate cubes-based map mesh from image data
void LoadMaterialsRetPtr(Material **ret, const char *fileName, int *materialCount){*ret=LoadMaterials(fileName, materialCount);}                    // Load materials from model file
void LoadMaterialDefaultRetPtr(Material *ret){*ret=LoadMaterialDefault();}                                                   // Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
void IsMaterialReadyRetPtr(bool *ret, Material material){*ret=IsMaterialReady(material);}                                              // Check if a material is ready
void LoadModelAnimationsRetPtr(ModelAnimation **ret, const char *fileName, int *animCount){*ret=LoadModelAnimations(fileName, animCount);}            // Load model animations from file
void IsModelAnimationValidRetPtr(bool *ret, Model model, ModelAnimation anim){*ret=IsModelAnimationValid(model, anim);}                         // Check model animation skeleton match
void CheckCollisionSpheresRetPtr(bool *ret, Vector3 center1, float radius1, Vector3 center2, float radius2){*ret=CheckCollisionSpheres(center1, radius1, center2, radius2);}   // Check collision between two spheres
void CheckCollisionBoxesRetPtr(bool *ret, BoundingBox box1, BoundingBox box2){*ret=CheckCollisionBoxes(box1, box2);}                                 // Check collision between two bounding boxes
void CheckCollisionBoxSphereRetPtr(bool *ret, BoundingBox box, Vector3 center, float radius){*ret=CheckCollisionBoxSphere(box, center, radius);}                  // Check collision between box and sphere
void GetRayCollisionSphereRetPtr(RayCollision *ret, Ray ray, Vector3 center, float radius){*ret=GetRayCollisionSphere(ray, center, radius);}                    // Get collision info between ray and sphere
void GetRayCollisionBoxRetPtr(RayCollision *ret, Ray ray, BoundingBox box){*ret=GetRayCollisionBox(ray, box);}                                    // Get collision info between ray and box
void GetRayCollisionMeshRetPtr(RayCollision *ret, Ray ray, Mesh mesh, Matrix transform){*ret=GetRayCollisionMesh(ray, mesh, transform);}                       // Get collision info between ray and mesh
void GetRayCollisionTriangleRetPtr(RayCollision *ret, Ray ray, Vector3 p1, Vector3 p2, Vector3 p3){*ret=GetRayCollisionTriangle(ray, p1, p2, p3);}            // Get collision info between ray and triangle
void GetRayCollisionQuadRetPtr(RayCollision *ret, Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4){*ret=GetRayCollisionQuad(ray, p1, p2, p3, p4);}    // Get collision info between ray and quad
void IsAudioDeviceReadyRetPtr(bool *ret){*ret=IsAudioDeviceReady();}                                  // Check if audio device has been initialized successfully
void GetMasterVolumeRetPtr(float *ret){*ret=GetMasterVolume();}                                    // Get master volume (listener)
void LoadWaveRetPtr(Wave *ret, const char *fileName){*ret=LoadWave(fileName);}                            // Load wave data from file
void LoadWaveFromMemoryRetPtr(Wave *ret, const char *fileType, const unsigned char *fileData, int dataSize){*ret=LoadWaveFromMemory(fileType, fileData, dataSize);} // Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
void IsWaveReadyRetPtr(bool *ret, Wave wave){*ret=IsWaveReady(wave);}                                    // Checks if wave data is ready
void LoadSoundRetPtr(Sound *ret, const char *fileName){*ret=LoadSound(fileName);}                          // Load sound from file
void LoadSoundFromWaveRetPtr(Sound *ret, Wave wave){*ret=LoadSoundFromWave(wave);}                             // Load sound from wave data
void LoadSoundAliasRetPtr(Sound *ret, Sound source){*ret=LoadSoundAlias(source);}                             // Create a new sound that shares the same sample data as the source sound, does not own the sound data
void IsSoundReadyRetPtr(bool *ret, Sound sound){*ret=IsSoundReady(sound);}                                 // Checks if a sound is ready
void ExportWaveRetPtr(bool *ret, Wave wave, const char *fileName){*ret=ExportWave(wave, fileName);}               // Export wave data to file, returns true on success
void ExportWaveAsCodeRetPtr(bool *ret, Wave wave, const char *fileName){*ret=ExportWaveAsCode(wave, fileName);}         // Export wave sample data to code (.h), returns true on success
void IsSoundPlayingRetPtr(bool *ret, Sound sound){*ret=IsSoundPlaying(sound);}                               // Check if a sound is currently playing
void WaveCopyRetPtr(Wave *ret, Wave wave){*ret=WaveCopy(wave);}                                       // Copy a wave to a new wave
void LoadWaveSamplesRetPtr(float **ret, Wave wave){*ret=LoadWaveSamples(wave);}                              // Load samples data from wave as a 32bit float data array
void LoadMusicStreamRetPtr(Music *ret, const char *fileName){*ret=LoadMusicStream(fileName);}                    // Load music stream from file
void LoadMusicStreamFromMemoryRetPtr(Music *ret, const char *fileType, const unsigned char *data, int dataSize){*ret=LoadMusicStreamFromMemory(fileType, data, dataSize);} // Load music stream from data
void IsMusicReadyRetPtr(bool *ret, Music music){*ret=IsMusicReady(music);}                                 // Checks if a music stream is ready
void IsMusicStreamPlayingRetPtr(bool *ret, Music music){*ret=IsMusicStreamPlaying(music);}                         // Check if music is playing
void GetMusicTimeLengthRetPtr(float *ret, Music music){*ret=GetMusicTimeLength(music);}                          // Get music time length (in seconds)
void GetMusicTimePlayedRetPtr(float *ret, Music music){*ret=GetMusicTimePlayed(music);}                          // Get current music time played (in seconds)
void LoadAudioStreamRetPtr(AudioStream *ret, unsigned int sampleRate, unsigned int sampleSize, unsigned int channels){*ret=LoadAudioStream(sampleRate, sampleSize, channels);} // Load audio stream (to stream raw audio pcm data)
void IsAudioStreamReadyRetPtr(bool *ret, AudioStream stream){*ret=IsAudioStreamReady(stream);}                    // Checks if an audio stream is ready
void IsAudioStreamProcessedRetPtr(bool *ret, AudioStream stream){*ret=IsAudioStreamProcessed(stream);}                // Check if any audio stream buffers requires refill
void IsAudioStreamPlayingRetPtr(bool *ret, AudioStream stream){*ret=IsAudioStreamPlaying(stream);}                  // Check if audio stream is playing
void ClampRetPtr(float *ret, float value, float min, float max){*ret=Clamp(value, min, max);}
void LerpRetPtr(float *ret, float start, float end, float amount){*ret=Lerp(start, end, amount);}
void NormalizeRetPtr(float *ret, float value, float start, float end){*ret=Normalize(value, start, end);}
void RemapRetPtr(float *ret, float value, float inputStart, float inputEnd, float outputStart, float outputEnd){*ret=Remap(value, inputStart, inputEnd, outputStart, outputEnd);}
void WrapRetPtr(float *ret, float value, float min, float max){*ret=Wrap(value, min, max);}
void FloatEqualsRetPtr(int *ret, float x, float y){*ret=FloatEquals(x, y);}
void Vector2ZeroRetPtr(Vector2 *ret){*ret=Vector2Zero();}
void Vector2OneRetPtr(Vector2 *ret){*ret=Vector2One();}
void Vector2AddRetPtr(Vector2 *ret, Vector2 v1, Vector2 v2){*ret=Vector2Add(v1, v2);}
void Vector2AddValueRetPtr(Vector2 *ret, Vector2 v, float add){*ret=Vector2AddValue(v, add);}
void Vector2SubtractRetPtr(Vector2 *ret, Vector2 v1, Vector2 v2){*ret=Vector2Subtract(v1, v2);}
void Vector2SubtractValueRetPtr(Vector2 *ret, Vector2 v, float sub){*ret=Vector2SubtractValue(v, sub);}
void Vector2LengthRetPtr(float *ret, Vector2 v){*ret=Vector2Length(v);}
void Vector2LengthSqrRetPtr(float *ret, Vector2 v){*ret=Vector2LengthSqr(v);}
void Vector2DotProductRetPtr(float *ret, Vector2 v1, Vector2 v2){*ret=Vector2DotProduct(v1, v2);}
void Vector2DistanceRetPtr(float *ret, Vector2 v1, Vector2 v2){*ret=Vector2Distance(v1, v2);}
void Vector2DistanceSqrRetPtr(float *ret, Vector2 v1, Vector2 v2){*ret=Vector2DistanceSqr(v1, v2);}
void Vector2AngleRetPtr(float *ret, Vector2 v1, Vector2 v2){*ret=Vector2Angle(v1, v2);}
void Vector2LineAngleRetPtr(float *ret, Vector2 start, Vector2 end){*ret=Vector2LineAngle(start, end);}
void Vector2ScaleRetPtr(Vector2 *ret, Vector2 v, float scale){*ret=Vector2Scale(v, scale);}
void Vector2MultiplyRetPtr(Vector2 *ret, Vector2 v1, Vector2 v2){*ret=Vector2Multiply(v1, v2);}
void Vector2NegateRetPtr(Vector2 *ret, Vector2 v){*ret=Vector2Negate(v);}
void Vector2DivideRetPtr(Vector2 *ret, Vector2 v1, Vector2 v2){*ret=Vector2Divide(v1, v2);}
void Vector2NormalizeRetPtr(Vector2 *ret, Vector2 v){*ret=Vector2Normalize(v);}
void Vector2TransformRetPtr(Vector2 *ret, Vector2 v, Matrix mat){*ret=Vector2Transform(v, mat);}
void Vector2LerpRetPtr(Vector2 *ret, Vector2 v1, Vector2 v2, float amount){*ret=Vector2Lerp(v1, v2, amount);}
void Vector2ReflectRetPtr(Vector2 *ret, Vector2 v, Vector2 normal){*ret=Vector2Reflect(v, normal);}
void Vector2RotateRetPtr(Vector2 *ret, Vector2 v, float angle){*ret=Vector2Rotate(v, angle);}
void Vector2MoveTowardsRetPtr(Vector2 *ret, Vector2 v, Vector2 target, float maxDistance){*ret=Vector2MoveTowards(v, target, maxDistance);}
void Vector2InvertRetPtr(Vector2 *ret, Vector2 v){*ret=Vector2Invert(v);}
void Vector2ClampRetPtr(Vector2 *ret, Vector2 v, Vector2 min, Vector2 max){*ret=Vector2Clamp(v, min, max);}
void Vector2ClampValueRetPtr(Vector2 *ret, Vector2 v, float min, float max){*ret=Vector2ClampValue(v, min, max);}
void Vector2EqualsRetPtr(int *ret, Vector2 p, Vector2 q){*ret=Vector2Equals(p, q);}
void Vector3ZeroRetPtr(Vector3 *ret){*ret=Vector3Zero();}
void Vector3OneRetPtr(Vector3 *ret){*ret=Vector3One();}
void Vector3AddRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Add(v1, v2);}
void Vector3AddValueRetPtr(Vector3 *ret, Vector3 v, float add){*ret=Vector3AddValue(v, add);}
void Vector3SubtractRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Subtract(v1, v2);}
void Vector3SubtractValueRetPtr(Vector3 *ret, Vector3 v, float sub){*ret=Vector3SubtractValue(v, sub);}
void Vector3ScaleRetPtr(Vector3 *ret, Vector3 v, float scalar){*ret=Vector3Scale(v, scalar);}
void Vector3MultiplyRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Multiply(v1, v2);}
void Vector3CrossProductRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3CrossProduct(v1, v2);}
void Vector3PerpendicularRetPtr(Vector3 *ret, Vector3 v){*ret=Vector3Perpendicular(v);}
void Vector3LengthRetPtr(float *ret, const Vector3 v){*ret=Vector3Length(v);}
void Vector3LengthSqrRetPtr(float *ret, const Vector3 v){*ret=Vector3LengthSqr(v);}
void Vector3DotProductRetPtr(float *ret, Vector3 v1, Vector3 v2){*ret=Vector3DotProduct(v1, v2);}
void Vector3DistanceRetPtr(float *ret, Vector3 v1, Vector3 v2){*ret=Vector3Distance(v1, v2);}
void Vector3DistanceSqrRetPtr(float *ret, Vector3 v1, Vector3 v2){*ret=Vector3DistanceSqr(v1, v2);}
void Vector3AngleRetPtr(float *ret, Vector3 v1, Vector3 v2){*ret=Vector3Angle(v1, v2);}
void Vector3NegateRetPtr(Vector3 *ret, Vector3 v){*ret=Vector3Negate(v);}
void Vector3DivideRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Divide(v1, v2);}
void Vector3NormalizeRetPtr(Vector3 *ret, Vector3 v){*ret=Vector3Normalize(v);}
void Vector3ProjectRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Project(v1, v2);}
void Vector3RejectRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Reject(v1, v2);}
void Vector3TransformRetPtr(Vector3 *ret, Vector3 v, Matrix mat){*ret=Vector3Transform(v, mat);}
void Vector3RotateByQuaternionRetPtr(Vector3 *ret, Vector3 v, Quaternion q){*ret=Vector3RotateByQuaternion(v, q);}
void Vector3RotateByAxisAngleRetPtr(Vector3 *ret, Vector3 v, Vector3 axis, float angle){*ret=Vector3RotateByAxisAngle(v, axis, angle);}
void Vector3LerpRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2, float amount){*ret=Vector3Lerp(v1, v2, amount);}
void Vector3ReflectRetPtr(Vector3 *ret, Vector3 v, Vector3 normal){*ret=Vector3Reflect(v, normal);}
void Vector3MinRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Min(v1, v2);}
void Vector3MaxRetPtr(Vector3 *ret, Vector3 v1, Vector3 v2){*ret=Vector3Max(v1, v2);}
void Vector3BarycenterRetPtr(Vector3 *ret, Vector3 p, Vector3 a, Vector3 b, Vector3 c){*ret=Vector3Barycenter(p, a, b, c);}
void Vector3UnprojectRetPtr(Vector3 *ret, Vector3 source, Matrix projection, Matrix view){*ret=Vector3Unproject(source, projection, view);}
void Vector3ToFloatVRetPtr(float3 *ret, Vector3 v){*ret=Vector3ToFloatV(v);}
void Vector3InvertRetPtr(Vector3 *ret, Vector3 v){*ret=Vector3Invert(v);}
void Vector3ClampRetPtr(Vector3 *ret, Vector3 v, Vector3 min, Vector3 max){*ret=Vector3Clamp(v, min, max);}
void Vector3ClampValueRetPtr(Vector3 *ret, Vector3 v, float min, float max){*ret=Vector3ClampValue(v, min, max);}
void Vector3EqualsRetPtr(int *ret, Vector3 p, Vector3 q){*ret=Vector3Equals(p, q);}
void Vector3RefractRetPtr(Vector3 *ret, Vector3 v, Vector3 n, float r){*ret=Vector3Refract(v, n, r);}
void MatrixDeterminantRetPtr(float *ret, Matrix mat){*ret=MatrixDeterminant(mat);}
void MatrixTraceRetPtr(float *ret, Matrix mat){*ret=MatrixTrace(mat);}
void MatrixTransposeRetPtr(Matrix *ret, Matrix mat){*ret=MatrixTranspose(mat);}
void MatrixInvertRetPtr(Matrix *ret, Matrix mat){*ret=MatrixInvert(mat);}
void MatrixIdentityRetPtr(Matrix *ret){*ret=MatrixIdentity();}
void MatrixAddRetPtr(Matrix *ret, Matrix left, Matrix right){*ret=MatrixAdd(left, right);}
void MatrixSubtractRetPtr(Matrix *ret, Matrix left, Matrix right){*ret=MatrixSubtract(left, right);}
void MatrixMultiplyRetPtr(Matrix *ret, Matrix left, Matrix right){*ret=MatrixMultiply(left, right);}
void MatrixTranslateRetPtr(Matrix *ret, float x, float y, float z){*ret=MatrixTranslate(x, y, z);}
void MatrixRotateRetPtr(Matrix *ret, Vector3 axis, float angle){*ret=MatrixRotate(axis, angle);}
void MatrixRotateXRetPtr(Matrix *ret, float angle){*ret=MatrixRotateX(angle);}
void MatrixRotateYRetPtr(Matrix *ret, float angle){*ret=MatrixRotateY(angle);}
void MatrixRotateZRetPtr(Matrix *ret, float angle){*ret=MatrixRotateZ(angle);}
void MatrixRotateXYZRetPtr(Matrix *ret, Vector3 angle){*ret=MatrixRotateXYZ(angle);}
void MatrixRotateZYXRetPtr(Matrix *ret, Vector3 angle){*ret=MatrixRotateZYX(angle);}
void MatrixScaleRetPtr(Matrix *ret, float x, float y, float z){*ret=MatrixScale(x, y, z);}
void MatrixFrustumRetPtr(Matrix *ret, double left, double right, double bottom, double top, double near, double far){*ret=MatrixFrustum(left, right, bottom, top, near, far);}
void MatrixPerspectiveRetPtr(Matrix *ret, double fovY, double aspect, double nearPlane, double farPlane){*ret=MatrixPerspective(fovY, aspect, nearPlane, farPlane);}
void MatrixOrthoRetPtr(Matrix *ret, double left, double right, double bottom, double top, double nearPlane, double farPlane){*ret=MatrixOrtho(left, right, bottom, top, nearPlane, farPlane);}
void MatrixLookAtRetPtr(Matrix *ret, Vector3 eye, Vector3 target, Vector3 up){*ret=MatrixLookAt(eye, target, up);}
void MatrixToFloatVRetPtr(float16 *ret, Matrix mat){*ret=MatrixToFloatV(mat);}
void QuaternionAddRetPtr(Quaternion *ret, Quaternion q1, Quaternion q2){*ret=QuaternionAdd(q1, q2);}
void QuaternionAddValueRetPtr(Quaternion *ret, Quaternion q, float add){*ret=QuaternionAddValue(q, add);}
void QuaternionSubtractRetPtr(Quaternion *ret, Quaternion q1, Quaternion q2){*ret=QuaternionSubtract(q1, q2);}
void QuaternionSubtractValueRetPtr(Quaternion *ret, Quaternion q, float sub){*ret=QuaternionSubtractValue(q, sub);}
void QuaternionIdentityRetPtr(Quaternion *ret){*ret=QuaternionIdentity();}
void QuaternionLengthRetPtr(float *ret, Quaternion q){*ret=QuaternionLength(q);}
void QuaternionNormalizeRetPtr(Quaternion *ret, Quaternion q){*ret=QuaternionNormalize(q);}
void QuaternionInvertRetPtr(Quaternion *ret, Quaternion q){*ret=QuaternionInvert(q);}
void QuaternionMultiplyRetPtr(Quaternion *ret, Quaternion q1, Quaternion q2){*ret=QuaternionMultiply(q1, q2);}
void QuaternionScaleRetPtr(Quaternion *ret, Quaternion q, float mul){*ret=QuaternionScale(q, mul);}
void QuaternionDivideRetPtr(Quaternion *ret, Quaternion q1, Quaternion q2){*ret=QuaternionDivide(q1, q2);}
void QuaternionLerpRetPtr(Quaternion *ret, Quaternion q1, Quaternion q2, float amount){*ret=QuaternionLerp(q1, q2, amount);}
void QuaternionNlerpRetPtr(Quaternion *ret, Quaternion q1, Quaternion q2, float amount){*ret=QuaternionNlerp(q1, q2, amount);}
void QuaternionSlerpRetPtr(Quaternion *ret, Quaternion q1, Quaternion q2, float amount){*ret=QuaternionSlerp(q1, q2, amount);}
void QuaternionFromVector3ToVector3RetPtr(Quaternion *ret, Vector3 from, Vector3 to){*ret=QuaternionFromVector3ToVector3(from, to);}
void QuaternionFromMatrixRetPtr(Quaternion *ret, Matrix mat){*ret=QuaternionFromMatrix(mat);}
void QuaternionToMatrixRetPtr(Matrix *ret, Quaternion q){*ret=QuaternionToMatrix(q);}
void QuaternionFromAxisAngleRetPtr(Quaternion *ret, Vector3 axis, float angle){*ret=QuaternionFromAxisAngle(axis, angle);}
void QuaternionFromEulerRetPtr(Quaternion *ret, float pitch, float yaw, float roll){*ret=QuaternionFromEuler(pitch, yaw, roll);}
void QuaternionToEulerRetPtr(Vector3 *ret, Quaternion q){*ret=QuaternionToEuler(q);}
void QuaternionTransformRetPtr(Quaternion *ret, Quaternion q, Matrix mat){*ret=QuaternionTransform(q, mat);}
void QuaternionEqualsRetPtr(int *ret, Quaternion p, Quaternion q){*ret=QuaternionEquals(p, q);}
void rlEnableVertexArrayRetPtr(bool *ret, unsigned int vaoId){*ret=rlEnableVertexArray(vaoId);}     // Enable vertex array (VAO, if supported)
void rlGetLineWidthRetPtr(float *ret){*ret=rlGetLineWidth();}                       // Get the line drawing width
void rlIsStereoRenderEnabledRetPtr(bool *ret){*ret=rlIsStereoRenderEnabled();}               // Check if stereo render is enabled
void rlGetVersionRetPtr(int *ret){*ret=rlGetVersion();}                           // Get current OpenGL version
void rlGetFramebufferWidthRetPtr(int *ret){*ret=rlGetFramebufferWidth();}                  // Get default framebuffer width
void rlGetFramebufferHeightRetPtr(int *ret){*ret=rlGetFramebufferHeight();}                 // Get default framebuffer height
void rlGetTextureIdDefaultRetPtr(unsigned int *ret){*ret=rlGetTextureIdDefault();}         // Get default texture id
void rlGetShaderIdDefaultRetPtr(unsigned int *ret){*ret=rlGetShaderIdDefault();}          // Get default shader id
void rlGetShaderLocsDefaultRetPtr(int **ret){*ret=rlGetShaderLocsDefault();}                // Get default shader locations
void rlLoadRenderBatchRetPtr(rlRenderBatch *ret, int numBuffers, int bufferElements){*ret=rlLoadRenderBatch(numBuffers, bufferElements);}  // Load a render batch system
void rlCheckRenderBatchLimitRetPtr(bool *ret, int vCount){*ret=rlCheckRenderBatchLimit(vCount);}                             // Check internal buffer overflow for a given number of vertex
void rlLoadVertexArrayRetPtr(unsigned int *ret){*ret=rlLoadVertexArray();}                               // Load vertex array (vao) if supported
void rlLoadVertexBufferRetPtr(unsigned int *ret, const void *buffer, int size, bool dynamic){*ret=rlLoadVertexBuffer(buffer, size, dynamic);}            // Load a vertex buffer attribute
void rlLoadVertexBufferElementRetPtr(unsigned int *ret, const void *buffer, int size, bool dynamic){*ret=rlLoadVertexBufferElement(buffer, size, dynamic);}     // Load a new attributes element buffer
void rlLoadTextureRetPtr(unsigned int *ret, const void *data, int width, int height, int format, int mipmapCount){*ret=rlLoadTexture(data, width, height, format, mipmapCount);} // Load texture in GPU
void rlLoadTextureDepthRetPtr(unsigned int *ret, int width, int height, bool useRenderBuffer){*ret=rlLoadTextureDepth(width, height, useRenderBuffer);}               // Load depth texture/renderbuffer (to be attached to fbo)
void rlLoadTextureCubemapRetPtr(unsigned int *ret, const void *data, int size, int format){*ret=rlLoadTextureCubemap(data, size, format);}                        // Load texture cubemap
void rlGetPixelFormatNameRetPtr(const char **ret, unsigned int format){*ret=rlGetPixelFormatName(format);}              // Get name string for pixel format
void rlReadTexturePixelsRetPtr(void **ret, unsigned int id, int width, int height, int format){*ret=rlReadTexturePixels(id, width, height, format);}              // Read texture pixel data
void rlReadScreenPixelsRetPtr(unsigned char **ret, int width, int height){*ret=rlReadScreenPixels(width, height);}           // Read screen pixel data (color buffer)
void rlLoadFramebufferRetPtr(unsigned int *ret, int width, int height){*ret=rlLoadFramebuffer(width, height);}              // Load an empty framebuffer
void rlFramebufferCompleteRetPtr(bool *ret, unsigned int id){*ret=rlFramebufferComplete(id);}                        // Verify framebuffer is complete
void rlLoadShaderCodeRetPtr(unsigned int *ret, const char *vsCode, const char *fsCode){*ret=rlLoadShaderCode(vsCode, fsCode);}    // Load shader from code strings
void rlCompileShaderRetPtr(unsigned int *ret, const char *shaderCode, int type){*ret=rlCompileShader(shaderCode, type);}           // Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
void rlLoadShaderProgramRetPtr(unsigned int *ret, unsigned int vShaderId, unsigned int fShaderId){*ret=rlLoadShaderProgram(vShaderId, fShaderId);} // Load custom shader program
void rlGetLocationUniformRetPtr(int *ret, unsigned int shaderId, const char *uniformName){*ret=rlGetLocationUniform(shaderId, uniformName);} // Get shader location uniform
void rlGetLocationAttribRetPtr(int *ret, unsigned int shaderId, const char *attribName){*ret=rlGetLocationAttrib(shaderId, attribName);}   // Get shader location attribute
void rlLoadComputeShaderProgramRetPtr(unsigned int *ret, unsigned int shaderId){*ret=rlLoadComputeShaderProgram(shaderId);}           // Load compute shader program
void rlLoadShaderBufferRetPtr(unsigned int *ret, unsigned int size, const void *data, int usageHint){*ret=rlLoadShaderBuffer(size, data, usageHint);} // Load shader storage buffer object (SSBO)
void rlGetShaderBufferSizeRetPtr(unsigned int *ret, unsigned int id){*ret=rlGetShaderBufferSize(id);}                      // Get SSBO buffer size
void rlGetMatrixModelviewRetPtr(Matrix *ret){*ret=rlGetMatrixModelview();}                                  // Get internal modelview matrix
void rlGetMatrixProjectionRetPtr(Matrix *ret){*ret=rlGetMatrixProjection();}                                 // Get internal projection matrix
void rlGetMatrixTransformRetPtr(Matrix *ret){*ret=rlGetMatrixTransform();}                                  // Get internal accumulated transform matrix
void rlGetMatrixProjectionStereoRetPtr(Matrix *ret, int eye){*ret=rlGetMatrixProjectionStereo(eye);}                        // Get internal projection matrix for stereo render (selected eye)
void rlGetMatrixViewOffsetStereoRetPtr(Matrix *ret, int eye){*ret=rlGetMatrixViewOffsetStereo(eye);}                        // Get internal view offset matrix for stereo render (selected eye)
void GuiIsLockedRetPtr(bool *ret){*ret=GuiIsLocked();}                               // Check if gui is locked (global state)
void GuiGetStateRetPtr(int *ret){*ret=GuiGetState();}                                // Get gui state (global state)
void GuiGetFontRetPtr(Font *ret){*ret=GuiGetFont();}                                // Get gui custom font (global state)
void GuiGetStyleRetPtr(int *ret, int control, int property){*ret=GuiGetStyle(control, property);}           // Get one style property
void GuiIconTextRetPtr(const char **ret, int iconId, const char *text){*ret=GuiIconText(iconId, text);} // Get text with icon id prepended (if supported)
void GuiGetIconsRetPtr(unsigned int **ret){*ret=GuiGetIcons();}                      // Get raygui icons data pointer
void GuiLoadIconsRetPtr(char ***ret, const char *fileName, bool loadIconsName){*ret=GuiLoadIcons(fileName, loadIconsName);} // Load raygui icons file (.rgi) into internal icons data
void GuiWindowBoxRetPtr(int *ret, Rectangle bounds, const char *title){*ret=GuiWindowBox(bounds, title);}                                       // Window Box control, shows a window that can be closed
void GuiGroupBoxRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiGroupBox(bounds, text);}                                         // Group Box control with text name
void GuiLineRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiLine(bounds, text);}                                             // Line separator control, could contain text
void GuiPanelRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiPanel(bounds, text);}                                            // Panel control, useful to group controls
void GuiTabBarRetPtr(int *ret, Rectangle bounds, const char **text, int count, int *active){*ret=GuiTabBar(bounds, text, count, active);}                  // Tab Bar control, returns TAB to be closed or -1
void GuiScrollPanelRetPtr(int *ret, Rectangle bounds, const char *text, Rectangle content, Vector2 *scroll, Rectangle *view){*ret=GuiScrollPanel(bounds, text, content, scroll, view);} // Scroll Panel control
void GuiLabelRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiLabel(bounds, text);}                                            // Label control, shows text
void GuiButtonRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiButton(bounds, text);}                                           // Button control, returns true when clicked
void GuiLabelButtonRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiLabelButton(bounds, text);}                                      // Label button control, show true when clicked
void GuiToggleRetPtr(int *ret, Rectangle bounds, const char *text, bool *active){*ret=GuiToggle(bounds, text, active);}                             // Toggle Button control, returns true when active
void GuiToggleGroupRetPtr(int *ret, Rectangle bounds, const char *text, int *active){*ret=GuiToggleGroup(bounds, text, active);}                         // Toggle Group control, returns active toggle index
void GuiToggleSliderRetPtr(int *ret, Rectangle bounds, const char *text, int *active){*ret=GuiToggleSlider(bounds, text, active);}                        // Toggle Slider control, returns true when clicked
void GuiCheckBoxRetPtr(int *ret, Rectangle bounds, const char *text, bool *checked){*ret=GuiCheckBox(bounds, text, checked);}                          // Check Box control, returns true when active
void GuiComboBoxRetPtr(int *ret, Rectangle bounds, const char *text, int *active){*ret=GuiComboBox(bounds, text, active);}                            // Combo Box control, returns selected item index
void GuiDropdownBoxRetPtr(int *ret, Rectangle bounds, const char *text, int *active, bool editMode){*ret=GuiDropdownBox(bounds, text, active, editMode);}          // Dropdown Box control, returns selected item
void GuiSpinnerRetPtr(int *ret, Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode){*ret=GuiSpinner(bounds, text, value, minValue, maxValue, editMode);} // Spinner control, returns selected value
void GuiValueBoxRetPtr(int *ret, Rectangle bounds, const char *text, int *value, int minValue, int maxValue, bool editMode){*ret=GuiValueBox(bounds, text, value, minValue, maxValue, editMode);} // Value Box control, updates input text with numbers
void GuiTextBoxRetPtr(int *ret, Rectangle bounds, char *text, int textSize, bool editMode){*ret=GuiTextBox(bounds, text, textSize, editMode);}                   // Text Box control, updates input text
void GuiSliderRetPtr(int *ret, Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue){*ret=GuiSlider(bounds, textLeft, textRight, value, minValue, maxValue);} // Slider control, returns selected value
void GuiSliderBarRetPtr(int *ret, Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue){*ret=GuiSliderBar(bounds, textLeft, textRight, value, minValue, maxValue);} // Slider Bar control, returns selected value
void GuiProgressBarRetPtr(int *ret, Rectangle bounds, const char *textLeft, const char *textRight, float *value, float minValue, float maxValue){*ret=GuiProgressBar(bounds, textLeft, textRight, value, minValue, maxValue);} // Progress Bar control, shows current progress value
void GuiStatusBarRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiStatusBar(bounds, text);}                                        // Status Bar control, shows info text
void GuiDummyRecRetPtr(int *ret, Rectangle bounds, const char *text){*ret=GuiDummyRec(bounds, text);}                                         // Dummy control for placeholders
void GuiGridRetPtr(int *ret, Rectangle bounds, const char *text, float spacing, int subdivs, Vector2 *mouseCell){*ret=GuiGrid(bounds, text, spacing, subdivs, mouseCell);} // Grid control, returns mouse cell position
void GuiListViewRetPtr(int *ret, Rectangle bounds, const char *text, int *scrollIndex, int *active){*ret=GuiListView(bounds, text, scrollIndex, active);}          // List View control, returns selected list item index
void GuiListViewExRetPtr(int *ret, Rectangle bounds, const char **text, int count, int *scrollIndex, int *active, int *focus){*ret=GuiListViewEx(bounds, text, count, scrollIndex, active, focus);} // List View with extended parameters
void GuiMessageBoxRetPtr(int *ret, Rectangle bounds, const char *title, const char *message, const char *buttons){*ret=GuiMessageBox(bounds, title, message, buttons);} // Message Box control, displays a message
void GuiTextInputBoxRetPtr(int *ret, Rectangle bounds, const char *title, const char *message, const char *buttons, char *text, int textMaxSize, bool *secretViewActive){*ret=GuiTextInputBox(bounds, title, message, buttons, text, textMaxSize, secretViewActive);} // Text Input Box control, ask for text, supports secret
void GuiColorPickerRetPtr(int *ret, Rectangle bounds, const char *text, Color *color){*ret=GuiColorPicker(bounds, text, color);}                        // Color Picker control (multiple color controls)
void GuiColorPanelRetPtr(int *ret, Rectangle bounds, const char *text, Color *color){*ret=GuiColorPanel(bounds, text, color);}                         // Color Panel control
void GuiColorBarAlphaRetPtr(int *ret, Rectangle bounds, const char *text, float *alpha){*ret=GuiColorBarAlpha(bounds, text, alpha);}                      // Color Bar Alpha control
void GuiColorBarHueRetPtr(int *ret, Rectangle bounds, const char *text, float *value){*ret=GuiColorBarHue(bounds, text, value);}                        // Color Bar Hue control
void GuiColorPickerHSVRetPtr(int *ret, Rectangle bounds, const char *text, Vector3 *colorHsv){*ret=GuiColorPickerHSV(bounds, text, colorHsv);}                // Color Picker control that avoids conversion to RGB on each call (multiple color controls)
void GuiColorPanelHSVRetPtr(int *ret, Rectangle bounds, const char *text, Vector3 *colorHsv){*ret=GuiColorPanelHSV(bounds, text, colorHsv);}                 // Color Panel control that returns HSV color value, used by GuiColorPickerHSV()
